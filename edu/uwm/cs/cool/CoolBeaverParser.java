/*
 * Copyright 2011 University of Wisconsin, Milwaukee
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package edu.uwm.cs.cool;

import beaver.*;
import java.util.Arrays;
import edu.uwm.cs.cool.scanner.CoolScanner;
import java.util.ArrayList;
import edu.uwm.cs.cool.tree.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "CoolBeaverParser.grammar".
 */
public class CoolBeaverParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short MINUS = 1;
		static public final short LPAREN = 2;
		static public final short OBJECTID = 3;
		static public final short LBRACE = 4;
		static public final short IF = 5;
		static public final short SUPER = 6;
		static public final short WHILE = 7;
		static public final short NEW = 8;
		static public final short BANG = 9;
		static public final short NULL = 10;
		static public final short INT_LIT = 11;
		static public final short STR_LIT = 12;
		static public final short BOOL_LIT = 13;
		static public final short DOT = 14;
		static public final short STAR = 15;
		static public final short FSLASH = 16;
		static public final short PLUS = 17;
		static public final short LT = 18;
		static public final short EQEQ = 19;
		static public final short LE = 20;
		static public final short MATCH = 21;
		static public final short SEMI = 22;
		static public final short RBRACE = 23;
		static public final short EQ = 24;
		static public final short TYPEID = 25;
		static public final short RPAREN = 26;
		static public final short VAR = 27;
		static public final short COLON = 28;
		static public final short ASSIGN = 29;
		static public final short NATIVE = 30;
		static public final short DEF = 31;
		static public final short CASE = 32;
		static public final short CLASS = 33;
		static public final short COMMA = 34;
		static public final short ARROW = 35;
		static public final short ELSE = 36;
		static public final short EXTENDS = 37;
		static public final short OVERRIDE = 38;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjbcTmLKKOXjzpxYM98X6af1024VGca108JK0HH4IHOa6QeY0Y8CM25EdIKI2KO1$7SVG" +
		"F#bCTPmJ5GbDi87O46mg2lM1TdxFPnCkzvsQS$8LxvpdlxhlxxUxPSyxkIlucZTPOdQVBTA" +
		"5wwb9Tgp4QhmcwIHELfIlD5ZK9L8tGg7bLbokcY8RK49MwP8WcArljrS5TMngZivIcl5gs5" +
		"emhJLTPhQEHLcVfbbgFhZPH9qjEf99IvPjZ6cnsQ8MQQeRkK7Ejn4rtRtI9Egchkgj0DvkT" +
		"wfBabge7xchrrHHbg5odw5Gjm5sRLBEP#ISqVZRk9HgekifKVPsX73N6NPzKynh65nO$Lrt" +
		"CQngdNBNGcNpByzGAz#p4ckPxtAHuyssOgy9GjoZKRHFgbgfrgDimoIjMMxLBS4zJcKwdzb" +
		"ByZcfWlY6ThSww5QsdLTMrpr6twdILhjCYdQj9gj3vwgKbke1vworVVNIHvkXYzJERr5y3D" +
		"4XNcAqQgc4QhX6wMjUPRTGSfUjfwGQuqMpNLDt6#dExfckQPfhlUBBpjKmBTQSMwsvpLCk9" +
		"k4jhp6$cLtD47hr456NbIkFzoR3lGbtkfHvFfP2rhBNL4ZJ8bV2yYebF7PMwf2dpaCaCrNV" +
		"NpX9pKS0xKBlMWd4LkF4rSUgZjHrTRQ9EbfnO9RdumKaaXphDbC$QbO#Ruzxe1go43JcZDB" +
		"PrifDSZvXipXgvlAjjY6f7Qn7S$AIQNVWsmk9pSLjnRKyFmJz2FnwQtB#VCZwBQn4ZYDgrD" +
		"uWl3OdtGkB3tKYecnVgjWnrWnaCSwD9Nip#ZtUpx9VlyGLdaifdB$HigWpjo9vILJi#iaeB" +
		"#SUOZM9RrfPxySbru1fZLGyYkjfqZ5woACrZfCt8vP3pxIncEeBIvdZ1SyqZ7poReBqWbsl" +
		"pUVQTAUAkejIKDYoG$GNf7Yuze5Az5Lp6eXNmNANdztDbsvnkTxh3nUQItkcyps03V0o7NN" +
		"dCbSrr#UcqMPVyx$0970fyOymnrry#r8VMq0XZCTe4NGj5y30KmnFumz1dqP7eLdGCkXijG" +
		"FUZ4z0Zw6JwUO0qVVhzOGO4xIvrVNBVNXey0WtXQMY1p$VWbvCkWItGZNml0i1tz#CjuZAG" +
		"$3nO3xDXFioXh2$ifPnn#4jW8JpeuWQJNeUEHeFvdW87Wh9KKA#OUJBeAbW6ZyBZi1hM44y" +
		"rZ$wzNyZVWsvsVUrpyHkTyepyUrtwlhZsduJxgH#Ca$dobgE1pvpx3v5$37qAc1$$6VAx4i" +
		"OtbE4TJHwtnxFpLhlqHkfrh#a#QUDW#FrxkvrM9FXx$qihFSxVas8UspbjxxJCQNUdFPtsS" +
		"JhGwI2d8vmE3zwzXBP7nQN7EXtdT7nSsKIdazmz7pw#7NLECVQfhhnRd3VDwKodivpE2MiZ" +
		"kStATI2klRa9#SLnwM49PGl#JnznzLU6UEKfnhMXKioVy8VSp$1s6xvaypFy13zQzuVgSbO" +
		"Xymgy32ywZvN6FA$gdzaCh5Bc8$WGFe3tu5tWYpNlcDUvVk5gVwwud$cqEdN0NlShvS$iW$" +
		"TXZytjDc#RjyoRvWspoxnWNaePTHWEmK6R#nA#Db$LqCjVvc#aDxk6P#bWyHqHrijqTdr11" +
		"7psSK4aZYXxLWQaGnf4xJvMHhqsTdU9M3hXTN8xJCmITQH37UTLQI9#3PuNWi#vt#Da7Pok" +
		"FKS4CgmMsPqmmfd5WmZdUezpVO3FoI9DXVy2AyeWq0==");

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	private Symbol wrap(Object obj) {
		return new Symbol(obj);
	}
	
	private scala.Symbol sym(String str) {
		return scala.Symbol$.MODULE$.apply(str);
	}
	
	private <T> scala.List<T> List(T... elements) {
		return scala.List$.MODULE$.apply((scala.Seq<T>) scala.collection.jcl.Conversions.convertList(Arrays.asList(elements)));
	}
	
	private scala.Nil$ Nil = scala.Nil$.MODULE$;
	
	// utilities from Cool.y
	
	private String filename = "<unknown>";
	private int num_errors = 0;
	private scala.List<Class_> result = (scala.List) Nil;
	private scala.Symbol superclass_name = null;
	private boolean current_inherit_status = true;
	
	// Code to help build constructors:
	private boolean constr_is_native = false;
	private scala.List<Expression> constr_body = (scala.List) Nil;
	private scala.List<Feature> attr_parameters = (scala.List) Nil;
	
	public void add_to_constructor(Expression e) { 
		constr_body = constr_body.$plus(e);
	}
	
	public Formal attr_parameter(scala.Symbol name, scala.Symbol typename) {
		scala.Symbol mod_name = sym(name.toString());
		attr_parameters = (scala.List) attr_parameters.$plus(new attr(name, typename));
		add_to_constructor(new assign(name, new variable(mod_name)));
		return new formal(mod_name, typename);
	}
	
	public void add_supercall(scala.Symbol supername, scala.List<Expression> actuals) {
		add_to_constructor(new static_dispatch(new variable(sym("this")),
						   supername, supername, actuals));
	}
	
	public void native_constructor() {
		constr_is_native = true;
	}
	
	public scala.List<Feature> make_constructor(scala.Symbol name, scala.List<Formal> formals) {
	    // #(
	    scala.List<Expression> body = (scala.List) constr_body.$plus(new variable(sym("this")));
		
		Expression bodyE = null;
		if (constr_is_native) {
			bodyE = new no_expr();
		} else {
	    	bodyE = new block(body);
		}
				 
	    Feature constr = new method(false, name, formals, name, bodyE);
	    
	    scala.List<Feature> result = attr_parameters.$plus(constr);
	    constr_is_native = false;
	    constr_body = (scala.List) Nil;
	    attr_parameters = (scala.List) Nil;
		
	    return result;
	}
	
	/* This function is called automatically when Bison detects a parse error. */
	public void yyerror(String message) {
		System.out.println(message);
	}

	private final Action[] actions;

	public CoolBeaverParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = class_list.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final scala.List<Class_> c = (scala.List<Class_>) _symbol_c.value;
					 return wrap(new program(c));
				}
			},
			Action.RETURN,	// [1] program = error
			new Action() {	// [2] class_list = class_decl.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final Class_ c = (Class_) _symbol_c.value;
					 return wrap(List(c));
				}
			},
			new Action() {	// [3] class_list = error SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return wrap(Nil);
				}
			},
			new Action() {	// [4] class_list = class_list.l class_decl.d
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final scala.List<Class_> l = (scala.List<Class_>) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final Class_ d = (Class_) _symbol_d.value;
					 return wrap(l.$plus(d));
				}
			},
			RETURN3,	// [5] class_list = class_list error SEMI; returns 'SEMI' although none is marked
			new Action() {	// [6] class_decl = CLASS TYPEID.t formals.f superclass.s LBRACE feature_list.l RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 2];
					final Symbol _symbol_f = _symbols[offset + 3];
					final scala.List<Formal> f = (scala.List<Formal>) _symbol_f.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final scala.Symbol s = (scala.Symbol) _symbol_s.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final scala.List<Feature> l = (scala.List<Feature>) _symbol_l.value;
					 return wrap(new class_((scala.Symbol) t.value, s,
			        l.$colon$colon$colon(make_constructor((scala.Symbol) t.value, f)),
			        sym(filename)));
				}
			},
			new Action() {	// [7] superclass = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 superclass_name = sym("Object"); 
						 add_supercall(superclass_name, (scala.List) Nil);
                         return wrap(superclass_name);
				}
			},
			new Action() {	// [8] superclass = EXTENDS TYPEID.nm actuals.act
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol nm = _symbols[offset + 2];
					final Symbol _symbol_act = _symbols[offset + 3];
					final scala.List<Expression> act = (scala.List<Expression>) _symbol_act.value;
					 superclass_name = (scala.Symbol) nm.value;
		                 add_supercall(superclass_name, act); 
		                 return wrap(superclass_name);
				}
			},
			new Action() {	// [9] superclass = EXTENDS NATIVE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 superclass_name = null; 
	       	             native_constructor();
	       	             return wrap(null);
				}
			},
			new Action() {	// [10] feature_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return wrap(Nil);
				}
			},
			new Action() {	// [11] feature_list = feature_list.ls feature.f SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 1];
					final scala.List<Feature> ls = (scala.List<Feature>) _symbol_ls.value;
					final Symbol _symbol_f = _symbols[offset + 2];
					final Feature f = (Feature) _symbol_f.value;
					 return wrap(ls.$plus(f));
				}
			},
			new Action() {	// [12] feature_list = feature_list.ls error SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 1];
					final scala.List<Feature> ls = (scala.List<Feature>) _symbol_ls.value;
					 return wrap(ls);
				}
			},
			new Action() {	// [13] feature_list = feature_list.ls NATIVE SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 1];
					final scala.List<Feature> ls = (scala.List<Feature>) _symbol_ls.value;
					 native_constructor(); return wrap(ls);
				}
			},
			new Action() {	// [14] feature_list = feature_list.ls LBRACE block.b RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 1];
					final scala.List<Feature> ls = (scala.List<Feature>) _symbol_ls.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 add_to_constructor(b);
		   return wrap(ls);
				}
			},
			new Action() {	// [15] feature = opt_override.opt DEF OBJECTID.id formals.form COLON TYPEID.ret ASSIGN expr.body
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_opt = _symbols[offset + 1];
					final Boolean opt = (Boolean) _symbol_opt.value;
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_form = _symbols[offset + 4];
					final scala.List<Formal> form = (scala.List<Formal>) _symbol_form.value;
					final Symbol ret = _symbols[offset + 6];
					final Symbol _symbol_body = _symbols[offset + 8];
					final Expression body = (Expression) _symbol_body.value;
					 return wrap(new method(opt, (scala.Symbol) id.value, form, (scala.Symbol) ret.value, body));
				}
			},
			new Action() {	// [16] feature = opt_override.opt DEF OBJECTID.id formals.form COLON TYPEID.ret NATIVE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_opt = _symbols[offset + 1];
					final Boolean opt = (Boolean) _symbol_opt.value;
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_form = _symbols[offset + 4];
					final scala.List<Formal> form = (scala.List<Formal>) _symbol_form.value;
					final Symbol ret = _symbols[offset + 6];
					 return wrap(new method(opt, (scala.Symbol) id.value, form, (scala.Symbol) ret.value, new no_expr()));
				}
			},
			new Action() {	// [17] feature = VAR OBJECTID.id COLON TYPEID.type ASSIGN expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 2];
					final Symbol type = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expression e = (Expression) _symbol_e.value;
					 add_to_constructor(new assign((scala.Symbol) id.value, e));
		   return wrap(new attr((scala.Symbol) id.value, (scala.Symbol) type.value));
				}
			},
			new Action() {	// [18] feature = VAR OBJECTID.id COLON NATIVE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 2];
					 /* if you have a native field, you cannot be inherited */
		  current_inherit_status = false; 
		  /* and your constructor is native */
		  native_constructor();
		  return wrap(new attr((scala.Symbol) id.value, sym("native")));
				}
			},
			new Action() {	// [19] opt_override = OVERRIDE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return wrap(true);
				}
			},
			new Action() {	// [20] opt_override = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return wrap(false);
				}
			},
			new Action() {	// [21] formals = LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return wrap(Nil);
				}
			},
			new Action() {	// [22] formals = LPAREN formal_list.ls RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 2];
					final scala.List<Formal> ls = (scala.List<Formal>) _symbol_ls.value;
					 return wrap(ls);
				}
			},
			new Action() {	// [23] formals = LPAREN error RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return wrap(Nil);
				}
			},
			new Action() {	// [24] formal_list = formal.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final Formal f = (Formal) _symbol_f.value;
					 return wrap(List(f));
				}
			},
			new Action() {	// [25] formal_list = formal_list.ls COMMA formal.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 1];
					final scala.List<Formal> ls = (scala.List<Formal>) _symbol_ls.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Formal f = (Formal) _symbol_f.value;
					 return wrap(ls.$plus(f));
				}
			},
			new Action() {	// [26] formal = OBJECTID.id COLON TYPEID.type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					final Symbol type = _symbols[offset + 3];
					 return wrap(new formal((scala.Symbol) id.value, (scala.Symbol) type.value));
				}
			},
			new Action() {	// [27] expr = OBJECTID.id ASSIGN expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return wrap(new assign((scala.Symbol) id.value, e));
				}
			},
			new Action() {	// [28] expr = SUPER DOT OBJECTID.id actuals.act
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_act = _symbols[offset + 4];
					final scala.List<Expression> act = (scala.List<Expression>) _symbol_act.value;
					 Expression this_obj = new variable(sym("this"));
	         return wrap(new static_dispatch(this_obj, superclass_name, (scala.Symbol) id.value, act));
				}
			},
			new Action() {	// [29] expr = expr.e DOT OBJECTID.id actuals.act
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_act = _symbols[offset + 4];
					final scala.List<Expression> act = (scala.List<Expression>) _symbol_act.value;
					 return wrap(new dispatch(e, (scala.Symbol) id.value, act));
				}
			},
			new Action() {	// [30] expr = IF LPAREN expr.e1 RPAREN expr.e2 ELSE expr.e3
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expression e2 = (Expression) _symbol_e2.value;
					final Symbol _symbol_e3 = _symbols[offset + 7];
					final Expression e3 = (Expression) _symbol_e3.value;
					 return wrap(new cond(e1, e2, e3));
				}
			},
			new Action() {	// [31] expr = WHILE LPAREN expr.e1 RPAREN expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new loop(e1, e2));
				}
			},
			new Action() {	// [32] expr = LBRACE block.b RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Expression b = (Expression) _symbol_b.value;
					 return wrap(b);
				}
			},
			new Action() {	// [33] expr = expr.e MATCH LBRACE case_list.ls RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_ls = _symbols[offset + 4];
					final scala.List<Case> ls = (scala.List<Case>) _symbol_ls.value;
					 return wrap(new typcase(e, ls));
				}
			},
			new Action() {	// [34] expr = NEW TYPEID.type actuals.act
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol type = _symbols[offset + 2];
					final Symbol _symbol_act = _symbols[offset + 3];
					final scala.List<Expression> act = (scala.List<Expression>) _symbol_act.value;
					 return wrap(new dispatch(new new_((scala.Symbol) type.value), (scala.Symbol) type.value, act));
				}
			},
			new Action() {	// [35] expr = expr.e1 PLUS expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new add(e1, e2));
				}
			},
			new Action() {	// [36] expr = expr.e1 MINUS expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new sub(e1, e2));
				}
			},
			new Action() {	// [37] expr = expr.e1 STAR expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new mul(e1, e2));
				}
			},
			new Action() {	// [38] expr = expr.e1 FSLASH expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new div(e1, e2));
				}
			},
			new Action() {	// [39] expr = MINUS expr.e1
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 2];
					final Expression e1 = (Expression) _symbol_e1.value;
					 return wrap(new neg(e1));
				}
			},
			new Action() {	// [40] expr = expr.e1 LT expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new lt(e1, e2));
				}
			},
			new Action() {	// [41] expr = expr.e1 EQ expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new eql(e1, e2));
				}
			},
			new Action() {	// [42] expr = expr.e1 EQEQ expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new dispatch(e1, sym("equals"), List(e2)));
				}
			},
			new Action() {	// [43] expr = expr.e1 LE expr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return wrap(new leq(e1, e2));
				}
			},
			new Action() {	// [44] expr = BANG expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return wrap(new comp(e));
				}
			},
			new Action() {	// [45] expr = LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return wrap(e);
				}
			},
			new Action() {	// [46] expr = NULL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return wrap(new unit());
				}
			},
			new Action() {	// [47] expr = INT_LIT.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol i = _symbols[offset + 1];
					 return wrap(new int_const((scala.Symbol) i.value));
				}
			},
			new Action() {	// [48] expr = STR_LIT.str
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol str = _symbols[offset + 1];
					 return wrap(new string_const((scala.Symbol) str.value));
				}
			},
			new Action() {	// [49] expr = BOOL_LIT.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol b = _symbols[offset + 1];
					 return wrap(new bool_const((Boolean) b.value));
				}
			},
			new Action() {	// [50] expr = OBJECTID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return wrap(new variable((scala.Symbol) id.value));
				}
			},
			new Action() {	// [51] expr = OBJECTID.id actuals.act
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_act = _symbols[offset + 2];
					final scala.List<Expression> act = (scala.List<Expression>) _symbol_act.value;
					 return wrap(new dispatch(new variable(sym("this")), (scala.Symbol) id.value, act));
				}
			},
			new Action() {	// [52] block = stmt_list.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 1];
					final scala.List<Expression> b = (scala.List<Expression>) _symbol_b.value;
					 return wrap(new block(b));
				}
			},
			new Action() {	// [53] stmt_list = expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 yyerror("deleted semicolon");
	          return wrap(List(e));
				}
			},
			new Action() {	// [54] stmt_list = expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return wrap(List(e));
				}
			},
			new Action() {	// [55] stmt_list = error
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return wrap(Nil);
				}
			},
			new Action() {	// [56] stmt_list = expr.e SEMI stmt_list.ls
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_ls = _symbols[offset + 3];
					final scala.List<Expression> ls = (scala.List<Expression>) _symbol_ls.value;
					 return wrap(ls.$colon$colon(e));
				}
			},
			new Action() {	// [57] stmt_list = VAR OBJECTID.id COLON TYPEID.type ASSIGN expr.e SEMI stmt_list.ls
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 2];
					final Symbol type = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_ls = _symbols[offset + 8];
					final scala.List<Expression> ls = (scala.List<Expression>) _symbol_ls.value;
					 return wrap(List(new let((scala.Symbol) id.value, (scala.Symbol) type.value, e, new block(ls))));
				}
			},
			new Action() {	// [58] stmt_list = error SEMI stmt_list.ls
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 3];
					final scala.List<Expression> ls = (scala.List<Expression>) _symbol_ls.value;
					 return wrap(ls);
				}
			},
			new Action() {	// [59] actuals = LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					  return wrap(Nil);
				}
			},
			new Action() {	// [60] actuals = LPAREN exp_list.ls RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 2];
					final scala.List<Expression> ls = (scala.List<Expression>) _symbol_ls.value;
					  return wrap(ls);
				}
			},
			new Action() {	// [61] exp_list = expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return wrap(List(e));
				}
			},
			new Action() {	// [62] exp_list = exp_list.ls COMMA expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ls = _symbols[offset + 1];
					final scala.List<Expression> ls = (scala.List<Expression>) _symbol_ls.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return wrap(ls.$plus(e));
				}
			},
			new Action() {	// [63] case_list = simple_cases.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final scala.List<Case> c = (scala.List<Case>) _symbol_c.value;
					 return wrap(c);
				}
			},
			new Action() {	// [64] simple_cases = simple_case.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final Case c = (Case) _symbol_c.value;
					 return wrap(List(c));
				}
			},
			new Action() {	// [65] simple_cases = simple_cases.cs simple_case.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_cs = _symbols[offset + 1];
					final scala.List<Case> cs = (scala.List<Case>) _symbol_cs.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final Case c = (Case) _symbol_c.value;
					 return wrap(cs.$plus(c));
				}
			},
			new Action() {	// [66] simple_case = CASE OBJECTID.id COLON TYPEID.type ARROW expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 2];
					final Symbol type = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expression e = (Expression) _symbol_e.value;
					 return wrap(new branch((scala.Symbol) id.value, (scala.Symbol) type.value, e));
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
